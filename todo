GENERAL:
setup a nice packaging system to allow everything to be installed via pip (except stupid opencl)

BASIN:
-- no A* for fault in basin
-- debug the basin problem.
-- brendan suggested that i compare to a full-space solution transitioning from a half-space to test the continuity boundary conditions
-- check on the free_edge_constraints stuff for basin, seems a little sketchy in terms of dofs...


SCIENCE:
fault intersecting surface -- this is actually a really hard problem, i should read about this problem and how to have conforming 
# Surface-fault joining algorithm?? 
# a surface can be treated as locally 2d, so it can be easily delaunay triangulated. therefore:
# 1) forget the local triangulation of the surface
# 2) project the top of the fault onto the topography.
# 3) add the fault top vertices to the surface vertices
# 4) re-delaunay the local triangulation of the surface. 
# 5) refine the triangulation until the triangles are reasonably sized.

variety of boundary conditions
gravity
-- test the 3D kernels
play with time stepping combined with fault friction 
plasticity? the plastic opening condition, maybe a viscoplastic opening condition? the kinematic consistency idea from brendan is really interesting! compare with a FEM model of explicit volumetric plasticity



2D AND LAPLACE
Adapt to 2D and Laplace in 3D.
-- create new 3bem golden master tests for each new step in development
-- catalog all the issues that would need to be resolved
-- parameterize everything on both the spatial dimension and the kernel tensor dimension
-- write 2D table construction code, should i use high order transformed gauss rules or should i use the adaptive integrators?
-- set up golden master tests that match with current 3D tectosaur results
-- set up golden master tests that match with old 3bem results



OPTIMIZATIONS:
-- figure out preconditioning, spilu is slow, but is there a better alternative? spai-based fmm inverse. sparse approximate inverse from FMM sparsity pattern
-- adjacent interpolation
-- adjacent from standard
-- build constraint matrix
-- assemble
-- vert adj prep
-- deal with low angle vertex adjacent cases -- these can be very expensive!
-- for some reason vert adj takes about the same time with GPU vs CPU, this indicates the GPU version is massively inefficient... why?
-- optimize the vertex adjacent integrals -- maybe check the angle between the triangles and choose an order based on that? either way, the standard VA pairs require only (4,4,4) quadrature while the really difficult ones require (9, 16, 6) for 1e-4 error.


PROBLEMDESCRIPTION
# -- CombinedMesh is handy even without multiple meshes, should i modify it or extend it so that it can be used more nicely for a single mesh situation (and has a better name!).
# -- should i create a nicer mesh data structure? consisting of the vertex and tri arrays with some other nice tools
# play with pygmsh, is it useful? anything else similar?

